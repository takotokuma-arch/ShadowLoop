
export function getVideoId(url: string): string | null {
    const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
    const match = url.match(regExp);
    return (match && match[2].length === 11) ? match[2] : null;
}

export function getThumbnailUrl(videoId: string): string {
    return `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;
}

export async function fetchTranscript(videoId: string): Promise<string> {
    try {
        // 1. Get Video Metadata from Piped API
        const response = await fetch(`https://pipedapi.kavin.rocks/streams/${videoId}`);
        if (!response.ok) throw new Error("Piped API request failed");

        const data = await response.json();
        const subtitles = data.subtitles;

        if (!subtitles || subtitles.length === 0) {
            throw new Error("No subtitles found via Piped API");
        }

        // 2. Select best subtitle (English > Japanese > First available)
        const track = subtitles.find((s: any) => s.code === 'en' && !s.autoGenerated) ||
            subtitles.find((s: any) => s.code === 'en') ||
            subtitles.find((s: any) => s.code === 'ja') ||
            subtitles[0];

        if (!track) throw new Error("No usable subtitle track found");

        // 3. Fetch the subtitle content
        const trackResponse = await fetch(track.url);
        const textData = await trackResponse.text();

        // 4. Parse VTT/SRT to pure text
        // Remove timestamps and VTT headers
        const lines = textData.split('\n');
        const cleanLines = lines.filter(line => {
            // Filter out timestamps (00:00:00.000 --> ...)
            if (line.match(/\d{2}:\d{2}:\d{2}\.\d{3}/)) return false;
            // Filter out headers and empty lines
            if (line.trim() === '' || line.includes('WEBVTT') || !isNaN(Number(line))) return false;
            return true;
        });

        // Remove duplicates (VTT often repeats lines for karaoke effect) and join
        const uniqueLines = cleanLines.filter((line, index, self) => {
            return index === 0 || line !== self[index - 1];
        });

        return uniqueLines.join(' ');

    } catch (e) {
        console.error("Piped API fetch failed:", e);
        throw new Error("Could not fetch transcript automatically (Piped API). Please use manual input.");
    }
}